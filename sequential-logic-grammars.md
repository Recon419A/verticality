# Sequential Logic Grammars 

Donald Bronson (Northwestern University)
 
## Abstract 

Existing solutions for procedural content generation primarily fall into one of two categories: systems which operate as dynamic agents and systems which generate content with a static single pass. In the middle is a growing field of hybrid generation systems, and in this paper we present the technique of sequential logic grammars, a grammar-based technique which makes use of sequential logical operations in order to allow

## Overview 

A sequential logic grammar consists of structured rules for the creation of an object, applied in sequential fashion, with each layer depending on the previous layers. Unlike standard grammars, they are not inherently recursive; like standard grammars, they involve multiple sequential steps and have a tendency to produce semi-fractal structures. In effect, a sequential logic grammar consists of a series of grammars in which the steps are temporally dependent in a linear fashion. 

Each stage in a sequential logic grammar follows the same procedure. First, a genotype is generated from the rules of the step’s grammar; this genotype is then combined with a series of restrictions and modifications which affect its final form, often dependent on the prior stages in the grammar. For instance, a grammar intended to produce stairs might have a possibility of producing a set of them in up to four locations per level; in a four-level structure with roof access, it might place three on the first level, two on the second level, none on the third level, and two on the fourth level. Following the determination of these stair locations, restrictions may be applied; for instance, if the stairs run along the outer walls, it might be inappropriate to place them such that they create a “floating” door. Because doors (in our example) are dynamically generated by a prior layer (the process is reversed for a posterior layer), the constraint of “do not spawn stairs beneath doors” cannot itself be coded into the grammar; instead, it must be applied dynamically at runtime. For this purpose, a simple Boolean check will suffice. If a door has already spawned on the east wall on Floor 3, the stairs on the east wall on Floor 2 should be removed from the genotype. In practice this is done by logical combination of two vectors of Booleans using a mapping of the logical AND operation – a staircase may only spawn if generated by the grammar AND allowed by the constraints. 

It is relatively easy to specify that a floor must have between one and four sets of stairs; indeed, one can do it by simple random population, such that `stairs[floor]` is an array of four IID booleans. It is also relatively easy to specify that stairs may not spawn immediately below a door; one may do this by mapping the logical formula 

```
stairs[floor][wall] = stairs[floor][wall] && !door[floor + 1][wall]
```

over all walls in the structure, taking care to account for end conditions. The larger challenge is presented by the back-propagation of constraints; if a single set of stairs is spawned by the grammar, and then subsequently removed because it has a door above it, we no longer satisfy the constraint of having between one and four sets of stairs per floor. To get around this problem, we introduce the concept of *sequential completeness*, by which we mean that each stage in the generation procedure is itself complete.

### The Generate-Filter Algorithm

Sequential logic grammars rely on a process known as generate-and-filter to create each layer in the sequence. To create a layer, that layer is first generated according to its own rules, which produces its *base genotype*. This base genotype is then constrained by a function which takes the previous layers as input in order to produce a *constrained genotype*. In our implementation, the genotype format is multi-dimensional array of booleans; using such a format, pairwise mapping of logical operators such as AND, OR, and NOT to various combinations of the layers results in an appropriately constrained layer. It should be noted that layers may never look forwards - any constraining which takes place must rely exclusively on prior layers, and once a layer is laid, that layer is final.

### Sequential Completeness and Noninterference

When generating structures using a sequential logic grammar, it is important to note that the filter step may remove the constraints implied by a grammar. To consider the problem, first conceive of a multi-story four-walled structure in which we want both wings leading off each floor and stairs between all the floors. We can achieve this by creating two layers: the first, a layer which spawns wings along each of the four walls with a fifty percent chance; the second, a layer which spawns stairs along each of the four walls with a fifty percent chance. To apply these layers in sequence, we simply apply the filter constraint to the stairs layer which says "do not spawn stairs if there is already a wing along this wall." Now we begin to see the problem - if we do this, and our algorithm somehow produces a floor with four wings leading off of it, we find that we have left ourselves with no locations to place stairs. Thus, a grammar that is designed to generate between one and four sets of stairs may in fact generate none that survive the filtering step. To solve this conundrum, we introduce the concepts of *sequential completeness* and *noninterference*.

#### Sequential Completeness

In a *sequentially complete* structure, each layer added causes the structure to appear complete, without reliance on future layers. In the above example, we could make our structure sequentially complete by changing the ordering of stairs and wings; if we generate the stairs first, our worst-case scenario structure is one with access to all four floors but no wings leading off of it. While such a structure is boring, it makes logical sense in a way that a structure with wings but no access between floors does not, since the entirety of our generated structure is reachable. Furthermore, the chance of generating a structure with no wings on any floor is significantly lower than the chance of generating a structure with no stairs on any *individual* floor - if one or two floors don't have wings, that's probably fine, but if one or two floors don't have stairs, that makes the entire rest of the structure inaccessible.

#### Noninterference

Sequential completeness resolves the problem of incomplete structures, but it can sometimes make certain features dominant over others. In the above example, we might find that stairs are far more likely to spawn than wings, since there are fewer restrictions on where they can spawn. In certain cases, this can be fine, but in our example it is clear that wings are more interesting and detailed structures than stairs are - perhaps even with their own recursive sequential logic grammar - and we might decide we want to see more of them. In this case, we can make use of *noninterference*. When two layers are *noninterfering*, they don't overlap and don't constrain each other. To achieve this with our wings and stairs, we might decide to replace wall-hugging stairwells with corner-hugging spiral stairs, such that the spawn locations of wings and stairs no longer overlap. Then, it becomes clear that we can drop entirely the filter constraint on wings - and in doing so, we revert to the purest form of the grammar that defines them. In this way, constraints are kept to a minimum, and flexibility is maximized.
